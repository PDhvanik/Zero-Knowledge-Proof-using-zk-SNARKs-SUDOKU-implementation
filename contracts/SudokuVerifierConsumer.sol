// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

// Import the actual Verifier contract
import "./Verifier.sol";

/**
 * @title SudokuVerifierConsumer
 * @notice Wraps the autogenerated Verifier.sol (Groth16) to store proven puzzles.
 * Uses the actual Verifier contract generated by snarkjs.
 */
contract SudokuVerifierConsumer {
    Groth16Verifier public verifier;

    struct ProofRecord {
        bool exists;
        bytes32 puzzleHash;
        uint256 timestamp;
    }

    mapping(bytes32 => ProofRecord) public proofs;

    event PuzzleProved(bytes32 indexed proofKey, bytes32 indexed puzzleHash, uint256 time);

    constructor(address _verifier) {
        verifier = Groth16Verifier(_verifier);
    }

    function _hashPuzzle(uint256[81] calldata unsolved, uint256[81] calldata clueFlags) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(unsolved, clueFlags));
    }

    function submitProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[162] calldata publicSignals,
        uint256[81] calldata unsolved,
        uint256[81] calldata clueFlags
    ) external {
        require(publicSignals.length == 162, "bad signals len");
        for (uint256 i=0;i<81;i++) {
            require(publicSignals[i] == unsolved[i], "unsolved mismatch");
            require(publicSignals[81+i] == clueFlags[i], "flags mismatch");
        }
        require(verifier.verifyProof(a, b, c, publicSignals), "invalid proof");

        bytes32 puzzleHash = _hashPuzzle(unsolved, clueFlags);
        bytes32 key = keccak256(abi.encodePacked(a, b, c, puzzleHash));
        require(!proofs[key].exists, "already stored");
        proofs[key] = ProofRecord({exists:true, puzzleHash:puzzleHash, timestamp:block.timestamp});
        emit PuzzleProved(key, puzzleHash, block.timestamp);
    }
}
